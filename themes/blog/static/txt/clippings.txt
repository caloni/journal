Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2682-86  | Added on Monday, 29 May 23 00:41:11 GMT-03:00

When the importing module needs to call into an imported function, the calling code typically looks like this: call [SomeAddress] Where SomeAddress is a pointer into the executable import address table (IAT). 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2755-56  | Added on Monday, 29 May 23 10:34:06 GMT-03:00

The I/O system is layered, which means that for each device there can be multiple device drivers that are stacked on top of each other. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2776-78  | Added on Monday, 29 May 23 10:37:40 GMT-03:00

The Win32 subsystem is the component responsible for every aspect of the Windows user interface. This starts with the low-level graphics engine, the graphics device interface (GDI), and ends with the USER component, which is responsible for higher-level GUI constructs such as windows and menus, and for processing user input. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2781-84  | Added on Monday, 29 May 23 10:38:36 GMT-03:00

First of all, it's important to realize that the components considered the Win32 subsystem are not responsible for the entire Win32 API, only for the USER and GDI portions of it. As described earlier, the BASE API exported from KERNEL32.DLL is implemented using direct calls into the native API, and has really nothing to do with the Win32 subsystem. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2784-87  | Added on Monday, 29 May 23 10:38:53 GMT-03:00

The Win32 subsystem is implemented inside the WIN32K.SYS kernel component and is controlled by the USER32.DLL and GDI32.DLL user components. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2789-92  | Added on Monday, 29 May 23 10:40:26 GMT-03:00

It can be helpful for reversers to become familiar with USER and GDI and with the general architecture of the Win32 subsystem because practically all user-interaction flows through them. Suppose, for example, that you're trying to find the code in a program that displays a certain window, or the code that processes a certain user event. The key is to know how to track the flow of such events inside the Win32 subsystem. From there it becomes easy to find the program code that's responsible for receiving or generating such events. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2794-95  | Added on Monday, 29 May 23 10:40:51 GMT-03:00

Because USER and GDI are both old components that were ported from ancient versions of Windows, they don't use the kernel object manager discussed earlier. Instead they each use their own little object manager mechanism. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2796-98  | Added on Monday, 29 May 23 10:41:40 GMT-03:00

Handles to Win32 objects such as windows and device contexts are essentially indexes into these object tables. The tables are stored and managed in kernel memory, but are also mapped into each process's address space for read-only access from user mode. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2798-2801  | Added on Monday, 29 May 23 10:42:41 GMT-03:00

Because the USER and GDI handle tables are global, and because handles are just indexes into those tables, it is obvious that unlike kernel object handles, both USER and GDI handles are global—if more than one process needs to access the same objects, they all share the same handles. In reality, the Win32 subsystem doesn't always allow more than one process to access the same objects; 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2807-10  | Added on Monday, 29 May 23 12:39:06 GMT-03:00

There are two basic types of exceptions: hardware exceptions and software exceptions. Hardware exceptions are exceptions generated by the processor, for example when a program accesses an invalid memory page (a page fault) or when a division by zero occurs. A software exception is generated when a program explicitly generates an exception in order to report an error. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2811-14  | Added on Monday, 29 May 23 12:39:32 GMT-03:00

In Windows, the throw keyword is implemented using the RaiseException Win32 API, which goes down into the kernel and follows a similar code path as a hardware exception, eventually returning to user mode to notify the program of the exception. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2815-18  | Added on Monday, 29 May 23 12:41:10 GMT-03:00

Structured exception handling means that the operating system provides mechanisms for “distributing” exceptions to applications in an organized manner. Each thread is assigned an exception-handler list, which is a list of routines that can deal with exceptions when they occur. When an exception occurs, the operating system calls each of the registered handlers and the handlers can decide whether they would like to handle the exception or whether the system should keep on looking. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2819-25  | Added on Monday, 29 May 23 12:41:29 GMT-03:00

The exception handler list is stored in the thread information block (TIB) data structure, which is available from user mode and contains the following fields: _NT_TIB: +0x000 ExceptionList : 0x0012fecc +0x004 StackBase : 0x00130000 +0x008 StackLimit : 0x0012e000 +0x00c SubSystemTib : (null) +0x010 FiberData : 0x00001e00 +0x010 Version : 0x1e00 +0x014 ArbitraryUserPointer : (null) +0x018 Self : 0x7ffde000 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2828-30  | Added on Monday, 29 May 23 12:42:29 GMT-03:00

How does a thread find its own TIB in runtime? On IA-32 processors, Windows uses the FS segment register as a pointer to the currently active thread-specific data structures. The current thread's TIB is always available at FS:[0]. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2831-33  | Added on Monday, 29 May 23 12:43:58 GMT-03:00

The ExceptionList member is the one of interest; it is the head of the current thread's exception handler list. When an exception is generated, the processor calls the registered handler from the IDT. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2833-52  | Added on Monday, 29 May 23 12:50:04 GMT-03:00

When an invalid memory address is accessed (an invalid memory address is one that doesn't have a valid page-table entry), the processor generates a page-fault interrupt (interrupt #14), and invokes the interrupt handler from entry 14 at the IDT. In Windows, this entry usually points to the KiTrap0E function in the Windows kernel. KiTrap0E decides which type of page fault has occurred and dispatches it properly. For user-mode page faults that aren't resolved by the memory manager (such as faults caused by an application accessing an invalid memory address), Windows calls into a user-mode exception dispatcher routine called KiUserExceptionDispatcher in NTDLL.DLL. KiUserExceptionDispatcher calls into RtlDispatchException, which is responsible for going through the linked list at ExceptionList and looking for an exception handler that can deal with the exception. The linked list is essentially a chain of _EXCEPTION_REGISTRATION_RECORD data structures, which are defined as follows: _EXCEPTION_REGISTRATION_RECORD: +0x000 Next : Ptr32 _EXCEPTION_REGISTRATION_RECORD +0x004 Handler : Ptr32 A bare-bones exception handler set up sequence looks something like this: 00411F8A push ExceptionHandler 00411F8F mov eax,dword ptr fs:[00000000h] 00411F95 push eax 00411F96 mov dword ptr fs:[0],esp This sequence simply adds an _EXCEPTION_REGISTRATION_RECORD entry into the current thread's exception handler list. The items are stored on the stack. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2853-64  | Added on Monday, 29 May 23 12:50:15 GMT-03:00

In real-life you will rarely run into simple exception handler setup sequences such as the one just shown. That's because compilers typically augment the operating system's mechanism in order to provide support for nested exception-handling blocks and for multiple blocks within the same function. In the Microsoft compilers, this is done by routing exception to the _except_handler3 exception handler, which then calls the correct exception filter and exception handler based on the current function's layout. To implement this functionality, the compiler manages additional data structures that manage the hierarchy of exception handlers within a single function. The following is a typical Microsoft C/C++ compiler SEH installation sequence: 00411F83 push 0FFFFFFFFh 00411F85 push 425090h 00411F8A push offset @ILT+420(__except_handler3) (4111A9h) 00411F8F mov eax,dword ptr fs:[00000000h] 00411F95 push eax 00411F96 mov dword ptr fs:[0],esp As you can see, the compiler has extended the _EXCEPTION_REGISTRATION_RECORD data structure and has added two new members. These members will be used by _except_handler3 to determine which handler should be called. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2865-68  | Added on Monday, 29 May 23 12:50:58 GMT-03:00

Beyond the frame-based exception handlers, recent versions of the operating system also support a vector of exception handlers, which is a linear list of handlers that are called for every exception, regardless which code generated it. Vectored exception handlers are installed using the Win32 API AddVectoredExceptionHandler. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2876-78  | Added on Monday, 29 May 23 12:52:39 GMT-03:00

Imagine an application making a sequence of system API calls. The application is essentially talking to the operating system, and the API is the language; if you understand the basics of the API in question, you can tune in to that conversation and find out what the application is saying. . . . 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2880-85  | Added on Monday, 29 May 23 12:53:10 GMT-03:00

If you'd like to proceed to develop a better understanding of operating systems, check out Operating System, Design and Implementation by Andrew S. Tanenbaum and Albert S. Woodhull [Tanenbaum2] Andrew S. Tanenbaum, Albert S. Woodhull, Operating Systems: Design and Implementation, Second Edition, Prentice Hall, 1997 for a generic study of operating systems concepts. For highly detailed information on the architecture of NT-based Windows operating systems, see Microsoft Windows Internals, Fourth Edition: Microsoft Windows Server 2003, Windows XP, and Windows 2000 by Mark E. Russinovich and David A. Solomon [Russinovich]. That book is undoubtedly the authoritative guide on the Windows architecture and internals. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2903-4  | Added on Monday, 29 May 23 12:56:26 GMT-03:00

Generally speaking, there are two fundamental reversing methodologies: offline analysis and live analysis. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2909-12  | Added on Monday, 29 May 23 17:23:49 GMT-03:00

The downside of offline code analysis is usually that a better understanding of the code is required (compared to live analysis) because you can't see the data that the program deals with and how it flows. You must guess what type of data the code deals with and how it flows based on the code. Offline analysis is typically a more advanced approach to reversing. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2919-20  | Added on Monday, 29 May 23 17:25:25 GMT-03:00

Generally, I'd say that live analysis is the better approach for beginners because it provides a lot more data to work with. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 2942-47  | Added on Tuesday, 30 May 23 01:04:59 GMT-03:00

In order to properly distinguish code from data, disassemblers must use recursive traversal instead of the conventional linear sweep Benjamin Schwarz, Saumya Debray, and Gregory Andrews. Disassembly of Executable Code Revisited. Proceedings of the Ninth Working Conference on Reverse Engineering, 2002. [Schwarz]. Briefly, the difference between the two is that recursive traversal actually follows the flow of the code, so that an address is disassembled only if it is reachable from the code disassembled earlier. A linear sweep simply goes instruction by instruction, which means that any data in the middle of the code could potentially confuse the disassembler. 
==========
Eldad Eilam - Reversing_ secrets of reverse engineering-Wiley (2005) (Eldad Eilam)
- Highlight Loc. 3013-17  | Added on Tuesday, 30 May 23 01:18:02 GMT-03:00

Software breakpoints are instructions added into the program's code by the debugger at runtime. These instructions make the processor pause program execution and transfer control to the debugger when they are reached during execution. Hardware breakpoints are a special CPU feature that allow the processor to pause execution when a certain memory address is accessed, and transfer control to the debugger. This is an especially powerful feature for reversers because it can greatly simplify the process of mapping and deciphering data structures in a program. 
==========
