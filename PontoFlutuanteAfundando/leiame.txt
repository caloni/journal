Quando armazenamos valores monetários em doubles seus cálculos conseguem manter a precisão e na maioria das vezes o ajuste de precisão funciona. Porém, encontrei alguns casos onde a subtração de dois valores fazia "perder" um centavo (ou comparações exatas) justamente pela limitação da precisão do ponto flutuante. Nesse exemplo os valores são 2.358,93 - 1.386,93, que em uma conta de padaria (mas correta) dá 972,00 (<a href="http://www.codinghorror.com/blog/2009/01/if-you-dont-change-the-ui-nobody-notices.html">até a Calc do Windows</a> e <a href="http://dqsoft.blogspot.com.br/2007/09/ser-que-o-excel-2007-desaprendeu.html">o Excel</a> funcionam), mas pelo Visual Studio 2010 chega perto, mas erra o alvo:

[github, PontoFlutuanteAfundando/PontoFlutuanteAfundando.cpp,cpp]

Isso ocorre porque sua representação dentro da variável double é diferente de 272.0 do outro double. Depurando vemos mais claramente:

<a href="http://www.flickr.com/photos/caloni/10726640115/" title="Ponto Flutuante Afundando por caloni, no Flickr"><img src="http://farm4.staticflickr.com/3787/10726640115_76bdf8a8eb_o.png" alt="Ponto Flutuante Afundando"></a>

Ou seja, quando fazemos a subtração de d2 em d1, nossa precisão raspa um pouquinho e escapa pela beirada:

<pre>
	d1	2358.9299999999998
	d2	1386.9300000000001
	======================
	d3	971.999999999999777
	    ||||||
		Esse é o valor "desejado".
</pre>

Na comparação com o valor redondo aparece a falha, mas note que isso não ocorre com os outros valores d1 e d2, já que o armazenamento adquire o mesmo formato:

<a href="http://www.flickr.com/photos/caloni/10726739335/" title="Ponto Flutuante Afundando (2) por caloni, no Flickr"><img src="http://farm4.staticflickr.com/3692/10726739335_b353225b51_o.png" alt="Ponto Flutuante Afundando (2)"></a>

Corrigindo o incorrigível
=========================

Há uma forma de arredondamento <a href="http://stackoverflow.com/questions/8316509/difference-dev-cpp-and-microsoft-visual-c-math-h">já disponível no C99</a> (mas não no Visual Studio 2010) que pode ser útil para esses casos. A única coisa que é preciso fazer é arredondar os valores antes do cálculo:

[github, PontoFlutuanteAfundando/PontoFlutuanteFlutuando.cpp,cpp]

É uma decisão arbitrária essa de arredondar para cima, mas se for adotada em todo o sistema (e já fazendo parte de um padrão, no caso, o C99), não deverão existir problemas de interpretação de cálculos entre os componentes.

O mercado financeiro agradece =).

<strong>UPDATE</strong>

Não estou de acordo com o armazenamento de valores monetários em doubles em vez de inteiros pelo simples motivo que <strong>não há moedas no sistema financeiro com unidades que se dividem ad infinitum</strong>. Por consequência, existe sempre uma unidade básica e indivisível (que no caso do Brasil é o centavo de real). Ou seja, como o objetivo é contar o total dessas unidades <strong>que não se dividem</strong>, o uso de inteiros é brainless.
