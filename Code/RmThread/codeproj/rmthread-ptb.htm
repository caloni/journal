<!--------------------------------------------------------------------------->
<!--                           INTRODUCTION                                

 The Code Project article submission template (HTML version)

Using this template will help us post your article sooner. To use, just 
follow the 3 easy steps below:
 
     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets. 

-->
<!--------------------------------------------------------------------------->
<!--                        IGNORE THIS SECTION                            --><html><head>
      <title>The Code Project</title>
      <style> BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
	H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
	H2 { font-size: 13pt; }
	H3 { font-size: 12pt; }
	H4 { font-size: 10pt; color: black; }
	PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
	CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
	</style>
      <link href="http://www.codeproject.com/styles/global.css" type="text/css" rel="stylesheet"></head>
   <body bgcolor="#ffffff" color="#000000">
      <!--------------------------------------------------------------------------->
      <!-------------------------------     STEP 1      --------------------------->
      <!--  Fill in the details (CodeProject will reformat this section for you) -->
      <pre>
Title:           RmThread
Autor:           Wanderley Caloni Jr.
Email:           blakhalk@ig.com.br
Ambiente:        VC6, VC7.1; XP, W2K
Palavras-chave:  RmThread, Code Injection, Remote, Thread
Nível:           Avançado
Descrição:       Um artigo sobre execução de código no contexto de outro processo.
Seção            C/C++
Sub-Seção        Técnicas
</pre>
      <!-------------------------------     STEP 2      --------------------------->
      <!--  Include download and sample image information.                       -->
      <ul class="download">
         <li>
            <a href="rmthread_demo.zip">Baixe o projeto de demonstração - XXX Kb </a>
         <li>
            <a href="rmthread_src.zip">Baixe o fonte - XXX Kb</a>
         </li>
      </ul>
      <p><img alt="RmThread demo in action!!!" src="rmthread.gif"></p>
      <!-------------------------------     STEP 3      --------------------------->
      <!--  Add the article text. Please use simple formatting (<h2>, <p> etc)   -->
      <h2>Introdução</h2>
      <p><strong>RmThread</strong> é um projeto que fiz baseado em uma das três idéias 
         do artigo de <a href="http://www.codeproject.com/script/profile/whos_who.asp?id=136330">
            Robert Kuster</a>, <a href="http://www.codeproject.com/threads/winspy.asp">"Three 
            Ways to Inject Your Code into Another Process"</a>. No entanto, não utilizei 
         código algum. Queria aprender sobre isso, pesquisei pela Internet, e me 
         influenciei pela técnica <code>CreateRemoteThread</code> &amp; <code>LoadLibrary</code>
      . O resto foi uma mistura de "chamada de funções certas" e MSDN.
      <p>
      O projeto que fiz é útil para quem precisa rodar algum código em um processo 
      vizinho, mas não quer se preocupar em desenvolver a técnica para fazer isso. 
      Quer apenas escrever o código que vai ser executado remotamente. O projeto 
      de demonstração, RmThread.exe, funciona exatamente como a técnica citada 
      anteriormente. Você diz qual o processo a ser executado e a DLL a ser 
      carregada, e ele inicia o processo e carrega a DLL em seu contexto. O resto 
      fica por conta do código que está na DLL.
      <p>Para fazer a DLL, existe um projeto de demonstração que se 
         utiliza de uma técnica que bolei para fazer rodar algum 
         código a partir da execução de <code>DllMain</code> sem ficar escravo de suas 
         limitações (você só pode chamar com segurança funções localizadas na 
         kernel32.dll).
         <h2>Usando o código</h2>
      <p>Existem três funções que poderão ser utilizadas pelo seu programa:</p>
      <pre>/** Run process and get rights for running remote threads. */
HANDLE CreateAndGetProcessGodHandle(LPCTSTR lpApplicationName, LPTSTR lpCommandLine);

/** Load DLL in another process. */
HMODULE RemoteLoadLibrary(HANDLE hProcess, LPCTSTR lpFileName);

/** Free DLL in another process. */
BOOL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule);</pre>
      <p>Eis a rotina principal simplificada demonstrando como é simples a utilização 
         das funções:
      </p>
      <pre>//...
   // Start process and get handle with powers.
   hProc = CreateAndGetProcessGodHandle(tzProgPath, tzProgArgs);

   if( hProc != NULL )
   {
      // Load DLL in the create process context.
      HMODULE hDll = RemoteLoadLibrary(hProc, tzDllPath);

      if( hDll != NULL )
         RemoteFreeLibrary(hProc, hDll);

      CloseHandle(hProc);
   }
//...</pre>
      <p>A parte mais complicada talvez seja o que fazer quando a sua DLL é carregada. 
         Considerando que ao ser chamada em seu ponto de entrada, o código da DLL possui 
         algumas limitações (uma já citada; para mais, vide a ajuda de <code>DllMain</code>
         no MSDN), fiz uma "execução alternativa", criando uma thread na 
         função <code>DllMain</code>:</p>
      <pre>BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
   switch( ul_reason_for_call )
   {
      case DLL_PROCESS_ATTACH:
      {
         DWORD dwThrId;

         // Fill global variable with handle copy of this thread.
         BOOL bRes =
         DuplicateHandle(GetCurrentProcess(),
                         GetCurrentThread(),
                         GetCurrentProcess(),
                         g_hThrDllMain,
                         0, 
                         FALSE, 
                         0);
         if( bRes == FALSE ) break;

         // Call function that do the useful stuff with its DLL handle.
         CloseHandle(CreateThread(NULL, 
                                  0,
                                  RmThread,
                                  (LPVOID) LoadLibrary(g_tzModuleName),
                                  0, 
                                  dwThrId));
      }
      break;
//...
</pre>
      <p>A função da thread, por sua vez, é esperar pela finalização da thread <code>DllMain</code>
         (temos o handle dessa thread armazenado em <code>g_hThrDllMain</code>), fazer o 
         que tem que fazer, e retornar, liberando ao mesmo tempo o handle da DLL criado 
         para si:</p>
      <pre>/**
 * Sample function, called remotely for RmThread.exe.
 */
DWORD WINAPI RmThread(LPVOID lpParameter)
{
   HMODULE hDll = (HMODULE) lpParameter;
   LPCTSTR ptzMsg = 
           _T("Congratulations! Did you call RmThread.dll successfully!");

   // Wait DllMain termination.
   WaitForSingleObject(g_hThrDllMain, INFINITE);

   //TODO: Put your remote code here.
   MessageBox(NULL,
              ptzMsg,
              g_tzModuleName,
              MB_OK | MB_ICONINFORMATION);
 
   // Do what the function name says.
   FreeLibraryAndExitThread(hDll, 0);
}</pre>
      <p>A marca TODO é aonde seu código deve ser colocado (você pode tirar o <code>MessageBox</code>, 
         se quiser). Como <code>DllMain</code> já foi previamente executada, essa parte 
         do código está livre para fazer o que quiser no contexto do processo vizinho.</p>
      <p>Um detalhe interessante é que é necessária a chamada de <code>FreeLibraryAndExitThread</code>. 
         Do contrário, após chamar <code>FreeLibrary</code>, o código a ser executado 
         depois (um simples <code>return</code>) estaria em um endereço de memória 
         inválido, já que a DLL não está mais carregada. O resultado não seria muito 
         agradável.</p>
      <h2>Pontos de Interesse</h2>
      <p>Um problema chato (que você poderá encontrar) é que, se a DLL não for carregada 
         com sucesso, não há uma maneira trivial de obter o código de erro da chamada de <code>
            LoadLibrary</code>. Uma vez que a thread inicia e termina nessa função API, 
         o LastError se perde. Alguma idéia?</p>
         <h2>Histórico</h2>
      <p>2004.06.11 - Versão 1.0.0.1 lançada.<br>
         2004.06.13 - Suporte ao formato de projeto do VC6.</p>
   </body>
</html>
