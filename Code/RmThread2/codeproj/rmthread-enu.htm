<!----------------------------- Article Starts ----------------------------->
<UL class="download">
	<LI>
		<A href="http://www.codeproject.com/threads/RmThread/rmthread_src.zip">Download 
			source files - 2.1 Kb</A>
	<LI>
		<A href="http://www.codeproject.com/threads/RmThread/rmthread_demo.zip">Download 
			demo project - 43.6 Kb</A>
	</LI>
</UL>
<P><IMG height="432" alt="Sample Image - rmthread.gif" src="rmthread.gif" width="594"></P>
<H2>Introduction</H2>
<P><B>RmThread</B> is a project that I made based on one of three ideas from the <A href="http://www.codeproject.com/script/profile/whos_who.asp?id=136330">
		Robert Kuster</A> article, <A href="http://www.codeproject.com/threads/winspy.asp">
		"Three Ways to Inject Your Code into Another Process"</A>. However, I didn't 
	use any code. I wanted to learn about it, searched over the net, and got 
	influenced by the <CODE>CreateRemoteThread</CODE> &amp; <CODE>LoadLibrary</CODE>
	technique. The rest was a prescription of "quite right function calls" and 
	MSDN.</P>
<P>The project is useful for someone who need to run some code in a neighbor 
	process, but doesn't want to worry about remote thread technique development. 
	He wants just to write the code to run remotely. The demo project, <I>RmThread.exe</I>, 
	works precisely to do the dirty thing. You say what process to run and the DLL 
	to load, and it starts the process and loads the DLL in the process context. 
	The rest remains in the DLL code.</P>
<P>To write your DLL, there's a demo project that uses a technique that I created 
	to run some code starting from the <CODE>DllMain</CODE> execution (apart from 
	another DLL function calling) and doesn't be a slave of its limitations (like: 
	you can safely call only <I>kernel32.dll</I> functions).</P>
<H2>Using the code</H2>
<P>There're three useful functions that could be called from your program:</P>
<PRE>/** Run process and get rights for running remote threads. */
HANDLE CreateAndGetProcessGodHandle(LPCTSTR lpApplicationName, 
                                            LPTSTR lpCommandLine);

/** Load DLL in another process. */
HMODULE RemoteLoadLibrary(HANDLE hProcess, LPCTSTR lpFileName);

/** Free DLL in another process. */
BOOL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule);</PRE>
<P>Here's a simplified main routine showing how simple it is to use the functions:</P>
<PRE>//...
   // Start process and get handle with powers.
   hProc = CreateAndGetProcessGodHandle(tzProgPath, tzProgArgs);

   if( hProc != NULL )
   {
      // Load DLL in the create process context.
      HMODULE hDll = RemoteLoadLibrary(hProc, tzDllPath);

      if( hDll != NULL )
         RemoteFreeLibrary(hProc, hDll);

      CloseHandle(hProc);
   }
//...</PRE>
<P>The most complicated thing maybe what to do when your DLL is loaded. 
	Considering that when it is called in your entry point, the DLL code has to 
	follow some boring rules to avoid boring things like access violations (for 
	more, read the <CODE>DllMain</CODE> help at MSDN). I made an "alternative 
	execution", creating a thread in the <CODE>DllMain</CODE> function:</P>
<PRE>BOOL APIENTRY DllMain(HANDLE hModule, 
        DWORD ul_reason_for_call, LPVOID lpReserved)
{
   switch( ul_reason_for_call )
   {
      case DLL_PROCESS_ATTACH:
      {
         DWORD dwThrId;

         // Fill global variable with handle copy of this thread.
         BOOL bRes =
         DuplicateHandle(GetCurrentProcess(),
                         GetCurrentThread(),
                         GetCurrentProcess(),
                         &amp;g_hThrDllMain,
                         0, 
                         FALSE, 
                         0);
         if( bRes == FALSE ) break;

         // Call function that do the useful stuff with its DLL handle.
         CloseHandle(CreateThread(NULL, 
                                  0,
                                  RmThread,
                                  (LPVOID) LoadLibrary(g_tzModuleName),
                                  0, 
                                  &amp;dwThrId));
      }
      break;
//...
</PRE>
<P>The tasks for our newly created thread, by its turn are, to wait for the <CODE>DllMain</CODE>
	finalization (we'd have its handle stored in <CODE>g_hThrDllMain</CODE>), to do 
	what it must to do (the all this stuff purpose), and to get back, releasing at 
	the same time the DLL handle allocated for itself:</P>
<PRE>/**
 * Sample function, called remotely for RmThread.exe.
 */
DWORD WINAPI RmThread(LPVOID lpParameter)
{
   HMODULE hDll = (HMODULE) lpParameter;
   LPCTSTR ptzMsg = 
           _T("Congratulations! You called RmThread.dll successfully!");

   // Wait DllMain termination.
   WaitForSingleObject(g_hThrDllMain, INFINITE);

   //TODO: Put your remote code here.
   MessageBox(NULL,
              ptzMsg,
              g_tzModuleName,
              MB_OK | MB_ICONINFORMATION);
 
   // Do what the function name says.
   FreeLibraryAndExitThread(hDll, 0);
}</PRE>
<P>The <B>TODO</B> mark is where your code must be written (you can pull out the <CODE>
		MessageBox</CODE>, if you want). Like <CODE>DllMain</CODE> code was 
	previously executed, this part of the code is free to do what it wants to do in 
	the neighbor process context.</P>
<P>An interesting detail is the requirement to call <CODE>FreeLibraryAndExitThread</CODE>. 
	In another way, if you call <CODE>FreeLibrary</CODE> and then return, the code 
	to be executed after that (a simple <CODE lang="asm">ret</CODE> assembly 
	instruction) would be in an invalid memory address (the DLL code is no more 
	loaded at the address space). So, the result could not be so delightful like 
	the final solution.</P>
<H2>Points of Interest</H2>
<P>A boring problem that you can find is: if the DLL couldn't be loaded 
	successfully, how can I get the error code? Unfortunately, there's no trivial 
	way to get the error code returned from <CODE>LoadLibrary</CODE> call. In order 
	for the thread to start and finish in this API function, the <CODE>LastError</CODE>
	code is lost (there's a <CODE>LastError</CODE> for each thread in the process). 
	Any idea?</P>
<H2>History</H2>
<UL>
	<LI>
	2004.06.11 - 1.0.0.1 version released.
	<LI>
		2004.06.13 - Support to VC6 project.
	</LI>
</UL>
<!----------------------------- Article Ends ----------------------------->
